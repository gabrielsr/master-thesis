% Related Work(0.5p)
% \section{Related Work}
% \label{sec:related}

In this chapter, we highlight the most closely related work.

% Other approaches for context-aware systems threat context-requirements as a tupla (context, requirement)\cite{knauss_acon:_2016}. These approaches handle the runtime of a context-requirements. When the context is valid the requirements apply. In this work, we handle the deployment view. Therefore, we need a different view: if the context is possible, the requirement should be satisfiable.



% In the literature, there are proposals that tackle the problem of handling changes at system context~\cite{knauss_acon:_2016}. These proposals focus on the system external context, reasoning about known facts about the external managed world and how it affects the systems goals.

\section{Goal Oriented Approaches}
Angelopoulos et al.~\cite{angelopoulos_capturing_2015} present an approach to handle  variability at three different dimensions: goals, behavior, and architecture. Variability can occur at goals dimension as an OR-refinement or context selection; at behavior dimension as different plans flows; and at the architecture dimension with the variability of components and implementations. However, their approach does not handle variability at deployment.

% Must of these approaches ignores variability in the computing environment, the underline computing resources that form the infrastructure for executing the system software. None of them solve the problem of software development for a highly variable environment from different software providers.
% Our approach focus on how move components to target environment.

Ali et~al.\cite{ali_requirements-driven_2014} explore the optimization of the deployment for a given context variability space in which the system will be deployed. Contextual Goal Model (CGM) was used to represent aspects of the environment related to the solution space, which was to be analyzed at design-time. This analysis at design-time can be used to evaluate which alternative strategy to implement.
It differs from our work in which we explore the context of the computing environment, not the solution space. Our approach allows for, at deployment time, choosing  between components already available. Both approaches could be used in tandem, as both rely on CGM but provide complementary kinds of analyses.

\section{Dynamic Software Product Lines Approaches}
Researchers have investigated Dynamic Software Product Line (DSPL) a way of adapt for variations in users requirements and system environments. DSPLs use the features models and  orthogonal variability models (OVMs) as techiniques for variaility management, to model what are valid variabilities.
% Dynamic variability (dynamic changes in the variation points and binding), context awareness, autonomous or self-adaptation are some of the necessary properties for Dynamic Software Product Line (DSPL), prescribed by Hallsteinsen et al.[0].‚Äù

DSPLs extend the concept of conventional SPLs by enabling software-variant generation at runtime. In classic SPL products can be derived from a SPL infrastructure for a specific customer individual or customer segment, in the assumption that the requirements for that customer and the execution environment will not change. In DSPLs a product can change to another configuration, in runtime, in response to a context change. To make it possible the feature model should be available at runtime. \cite{bencomo_view_2012}

Bencomo et al.~\cite{bencomo_dynamically_2008} use a SPL approach to adaptation. It  associates an architecture variability model with an environment variability model. The environment variability is modeled as a transition system. The structural variability is responsible for the system adaptation. A configuration or a product is a set of selected components. A configuration is associated with states in the environment variability model. Unlike our approach, their focus is on the adaptation in the configuration at runtime but not on the deployment itself. Mizouni et al. \citep{mizouni_framework_2014} use a feature model associated with context requirements.

%In order to allow a decentralized evolution of the system, Goalp do not rely on a centralized model created at design-time. Instead, metadata present into artifacts contained into an artifact repository is used. This allows third party developers to provide software components with different restrictions of the original developer, creating more variability and in consequence, allowing the application to be executed in a more broad range of devices.
Leite et al.~\cite{ferreira_leite_user_2014} propose an approach for automatic deployment on inter-cloud environments. It relies on abstract and concrete features models and constraint satisfaction problem solver to create a computing environment using resources distributed across various clouds.
It integrates a self-healing schema for cloud deployment based on which virtual machines in the cloud are monitored and in the case of failure the machine can be
restarted or terminated and then a new one created.
The approach is specific to cloud environments and requires instantiating at design-time a model knowledgeable about the environment.
It also strongly depends on design-time created scripts to realize the deployment of an application, which limits the autonomy of the approach, especially in unknown environments.


\section{?? Approaches}

Gunalp et al.~\citep{gunalp_rondo_2015} presents an approach for automatic deployment, in which the deployment specialist specifies the system deployment in terms of resources and desired target states of such resources. The approach follows preset strategies to keep the managed software resources in the specified states. They use a low-level model to drive the adaptation: implemented strategies to move watched resources to target states. Differently, our approach uses a goal model which is a more abstract model.


\section{Package managers}
Package managers, such as Debian package manager\cite{aoki_debian_2016}, are capable of solving dependencies and deploying software, however, their approach to heterogeneity is limited. In Debian package manager, the heterogeneity is handled for processor architecture and version of operating system. There are separated repositories for each specification of architecture and operating system. The users' machines have only repositories registered with compatible repositories.
In our approach, separated repositories are not required, context conditions are evaluated for each artifact instead.
Another difference is in how dependencies are wired. They require that a managed application declare their dependencies by name and version. In our approach, differently, the dependencies are declared in terms of interfaces for which implementations are required, not specific implementations.
This requirement declaration, in terms of interface, associated with context conditions allow for a more flexible dependency resolution at deployment-time.

\begin{table*}[!ht]
\centering
\caption{Comparing characteristic properties of selected approaches related to Goalp}
\label{table_related_works}
\begin{tabular}{p{4cm} ccc}
\toprule
Work by &
   Goal Oriented &
    Handle Heterogeneity &
    Autonomic Deployment \\
\midrule
Ali et al.\citep{ali_requirements-driven_2014} & \cellcolor{blue!10} Yes & No & No \\
Angelopoulos et al. \cite{angelopoulos_capturing_2015} & \cellcolor{blue!10}Yes & No & No \\
Mizouni et al. \citep{mizouni_framework_2014} & No & \cellcolor{blue!10} Yes & No \\
Leite et al. \citep{ferreira_leite_user_2014}  & No & \cellcolor{blue!10} Yes & No \\
Gunalp et al.\citep{gunalp_rondo_2015} & No & \cellcolor{blue!10} Yes  &  No\\
Goalp & \cellcolor{blue!10} Yes & \cellcolor{blue!10} Yes & \cellcolor{blue!10} Yes \\
\bottomrule
\end{tabular}
\end{table*}

Table~\ref{table_related_works} summarizes work most related to Goalp. Ali et al.\citep{ali_requirements-driven_2014} and Angelopoulos et al. \cite{angelopoulos_capturing_2015} works are both goal-oriented works that handle variability at the design of a system, however, they do not handle heterogeneity in the computing environment and has no support adaptation in the deployment time. Mizouni et al. \citep{mizouni_framework_2014}, Leite et al. \citep{ferreira_leite_user_2014} and Gunalp et al.\citep{gunalp_rondo_2015} works' handle some kind of adaptation at deployment time but uses a low-level model to drive the adaptation which requires a knowledge about the computing environment at design-time.


% While package mangers such as aptitude and RPM can get components and handle some variabilities, e.g CPU architecture, they are not adaptive, so they not handle changes in the computing environment at runtime. They favor reuse at a library level. We propose reuse at component level.
