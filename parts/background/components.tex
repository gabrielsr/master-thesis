\section{Software Components}
Heineman defines \emph{software component} as a
\say{software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard}\cite{heineman_component-based_2001}.

Software components are units of composition. Software systems are built by composing different components.  Software components must conform to a component model by having contractually specified interfaces and explicit context dependencies only.\cite{szyperski_component_2002}.

A \emph{component	interface} \say{defines a set of component functional properties, that is, a set of actions understood by both the interface provider (the component) and user (other components, or other software that interacts with the provider)}\cite{crnkovic_software_2011}.
A component interface has a role as a component specification and also a means for interaction between the component and its environment.
A \emph{component model} is a set of standards for a component implementation. These standards can standardize naming, interoperability, customization, composition, evolution and deployment.\cite{heineman_component-based_2001}
The \emph{component deployment} is the process that enables component integration into the system. A deployed component is registered in the system and ready to provide services\cite{crnkovic_software_2011}.
\emph{Component binding} is the process that connects different components through their interfaces and interaction channels.

Software architecture deals with the definition of components, their external behavior, and how they interact\cite{kaur_component_2010}. The architectural view of a software can be formalized via an architecture description language (ADL)\cite{medvidovic_classification_2000}.


Component-based software engineering (CBSE) approach consists of building systems from components as reusable units and keeping component development separate from system development\cite{crnkovic_software_2011}.

CBSE is built on the following four principles\cite{crnkovic_software_2011}:
\begin{itemize}
  \item \emph{Reusability}. Components, developed once, have the potential for reuse many times in different applications.
  \item \emph{Substitutability}. Systems maintain correctness even when one component replaces another.
  \item \emph{Extensibility}. Extensibility aims to support evolution by adding new components or evolving existing ones to extend the system’s functionality.
  \item \emph{Composability}. A system should support the composition of functional properties (component binding). Composition of extra functional properties, for example, composition of components’ reliability, is another possible form of composition.
\end{itemize}

\subsection{Component-Based Adaptation}

In the literature, there has been proposals of framework for architecture and components based adaptation.

Rainbow\cite{garlan_rainbow:_2004} is a framework for architecture based self-adaptation. It keeps a model of the architecture of the system and can be extended with rules to analyze the system behavior at runtime, find adaptation strategies and perform changes. It separates the functional code (internal mechanisms) from adaptation code (external mechanism) in a schema called external control, influenced by control theory.

MUSIC\cite{rouvoy_music:_2009} project provides a component-based middleware for adaptation that proposes to separate the self-adaptation from business logic and delegate adaptation logic to generic middleware. It adapts by evaluating in runtime the utility of alternatives, to chose a feasible one (e.g., the one evaluated as with highest utility).

Flashmob~\cite{sykes_flashmob:_2011} is an approach for distributed self-assembly. Different from MUSIC and Rainbow, it handles component-based adaptation in a distributed environment. The self-assembly can be described as: given a set of available components (with various functional and non-functional properties), and a configuration of components which are already running, find a new configuration which works (better) in the changed execution environment (including hardware),
meets new user requirements or takes account of new component implementations~\cite{sykes_flashmob:_2011}. Flashmod uses a three-layer model: goals, management and components proposed by Kramer and Magee~\cite{kramer_self-managed_2007}, extending it to allow distributed agreement in a given configuration.

OSGi\cite{the_osgi_alliance_osgi_2007} is a Java centric platform that allows dynamic bind and unbind of components, usually named bundles. Ferreira et al.\cite{ferreira_-osgi:_2012} proposed a framework for adaptation based on OSGi.

\subsection{From Goals to Components}

Lamsweerde \cite{van_lamsweerde_system_2003} presents a method for deriving architecture from KAOS goal model\cite{dardenne_goal-directed_1993}. Firstly, an abstract draft is generated from functional goals. Secondly, the architecture is refined to meet non-functional requirements such as cohesion.

% Penserini \citep{penserini_design_2007} propose a method for generate agents from goal models.
% Morandini \cite{morandini_towards_2008}
% Tropos - Jadex-BDI}
Pimentel et al. \cite{pimentel_deriving_2012} present a method  using i* models to produce architectural models in Acme, a language employed to describe architectural models.  Firstly, i* model is transformed into a modular i* model employing a horizontal transformation. Secondly, an architecture model is created from the i* modularized model employing a vertical transformation. Architectural design models is made easier by the
presence of actor and dependency concepts.

Yu et al.~\cite{yu_goals_2008} proposed an approach for keeping the variability that exists in the goal model into the architecture.
It presents a method for creating a component-connector view from a goal model.
A preliminary component-connector view is generated from a goal model by creating an interface type for each goal. The interface name is directly derived from the goal name. Goals refinements result in the implementation of components.
If a goal is And-decomposed, the component has as many \emph{requires} interfaces as subgoals.

\begin{lstlisting}
Component G {
  provides IG;
  requires IG1, IG2;
}
\end{lstlisting}

If the goal is OR-decomposed, the interface type of subgoals are the interface type of the parent goal.
%It's the most important patterns as it allow variability at architecture.

\begin{lstlisting}
Component G1 {
  provides IG;
}

Component G2 {
  provides IG;
}
\end{lstlisting}

% A component equivalent to the parent goal is generated with a switch.


%TODO Input and outputs are added to the interface.

%TODO Related lower level components can be merged by parametrization.



% Asadie et al.~\cite{asadi_goal-oriented_2011} relates Goal-Oriented requirements and feature models for the development of SPL using a goal-oriented approach. In the described approach Goal-Models complement feature-models providing a mechanism to choose a set of features from stakeholder intentions.

% GOAL-Architecture
% In this work we present a Goal-Architecture view. Such view was presented in the literature. STREAM-A\cite{pimentel_deriving_2012} create specialized agents. We create components. Components are not agents as they do not have autonomy, instead they are means of achieving a goal.
% Different for other works
