\subsubsection{Dependency Injection}

Dependency Injection is a pattern that allows for wiring together software components that were developed without the knowledge about each other.~\cite{fowler_inversion_2004}

In OO languages normally one instantiates an object from a class using an operator (\emph{new} for Java) and a reference to such class.
Interfaces create architecture independence. Yet, even using interfaces we can can have static dependencies at some point, at the implementation instantiation.
The object that is instantiating (the client) is dependent on the referenced class (the service).

So the use of the \emph{new} operator lead to the following disadvantages:
\begin{itemize}
  \item impose compile time dependency between two classes
  \item impose runtime dependency between two classes
\end{itemize}

In case of strongly typed languages, normally one will get an exception if the referenced class is not present.

The basic idea of the Dependency Injection is to have a separate object, an \emph{assembler}, that wires together the components at runtime\cite{fowler_inversion_2004}. The client class refers to the service using its interface (the service interface). The assembler can use alternative ways to the \emph{new} to instantiate an object so that the wiring between client objects and implementation service classes could be postponed to runtime. Using reflexive platforms we can eliminate the static dependency as the platform can find available interfaces implementations at runtime.
The assembler can use reflexive capabilities of the platform to discover the available implementations and instantiate them.

In the context of component-based adaptation, decoupling client components from service components would be specially useful, allowing runtime reasoning about what implementation to choose.
%
% \begin{figure}[h!]\centering
%
% \begin{tikzpicture}
%   \begin{umlpackage}[x=4,y=0]{service interface}
%     \umlemptyclass[width=15ex]{IServiceA}
%   \end{umlpackage}
%   \begin{umlpackage}[x=4,y=-3]{service implementation}
%     \umlemptyclass[width=15ex]{ServiceAImpl}
%     \umlimpl{ServiceAImpl}{IServiceA}
%   \end{umlpackage}
%   \begin{umlpackage}[x=0,y=0]{Client}
%     \umlemptyclass[width=15ex]{ClientOfServiceA}
%     \umlassoc{ClientOfServiceA}{IServiceA}
%   \end{umlpackage}
%   \begin{umlpackage}[x=0,y=-3]{Assembler}
%   \end{umlpackage}
% \end{tikzpicture}
%
% \caption{Two components}
% \end{figure}

% \subsubsection{Inversion of Control Containers}
% \label{sec:iocc}
%
% It have been used as a core principle in the development of popular frameworks like Sprint and Angular.
