% (.5p)
\section{Introduction}
As the frontier of computing system expands to more aspects of human life we get more systems that is meant to run in dynamic computing environment. Developing software for such environment is challenging~\cite{baresi_toward_2006}.

Example of domains that leads towards dynamic environments are Ubiquitous Computing~\cite{bell_yesterdays_2007}, Internet of Things (IoT)\cite{atzori_internet_2010}, Assisted Living\cite{kleinberger_ambient_2007}, and Opportunistic Computing\cite{smaldone_improving_2011}. In such domains, the computing environment is dynamic as computer nodes can enter and leave the application. Also the computing environment can be highly heterogeneous as users have different sets of devices with different resources and characteristics. In addition, some characteristics of the computing environment can be unknown at design-time. For example, in a smart home application developer can know very little about the set of devices in the end-user home computing network.

Software deployment is the process of get a software ready to user in a given computing environment. Software deployment involves planning the deployment by assigning roles to a given computer node, selecting artifacts that must be present in the node and services that in must provide and consume. Also software deployment evolves copying artifacts for a target computing environment and setting appropriate configurations.

Traditionally software deployment is considered and human-centered activity only once executed. Such traditional view do not fit a dynamic computing environment, because in such environment the deployment should be adapted frequently. Previous works have explored goal-driven adaptation of dynamic systems at different aspects, such as configuration, behavior and structure\cite{yu_goals_2008}. Although, there is still a lack of proposals for platforms to handle autonomous deployment for dynamic environments.


%Some works model how context relate to system requirements [Rain and Dalpiaz works]. Other works use pre-designed plans to change the system architecture to respond to context changes [architecture based adapatiaion references]. Ali et al. \cite{ali_requirements-driven_2014}

%In our ongoing research, we use goal model as a solution for requirements reflection \cite{bencomo_requirements_2010}. Using this approach, we keep a requirements representation as a runtime artifact and can reflect about it during execution in order to decide on adaptations.

%We also use concepts from multiagent systems. Multiagent reasoning can lead to distributed, scalable system without a single point of failures. The advantages of using a MAS approach is the distributed nature of the system and to avoid have a sigle point of failure.

 %In special, we are interested in self-assembly and fault-tolerance in decentralized systems. This work focus on a conceptual model for implement systems with self-assembly and fault-tolerance.

%To make opportunistic computing a reality, middleware services must mask disconnections and delays and manage heterogeneous computing resources, services, and data to provide a uniform view of the system to the applications.\cite{conti_opportunities_2010}


% TODO Advantages of our approach

%In this paper, we will focus on deployment planing, for handling variability in the computing environment.
%We extend goal models with concept of resource dependency and system components. We propose a method for plan a deployment given a set of system goals, system components and available resources.
