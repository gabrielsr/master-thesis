This work propose a method for autonomous deployment driven by context-goal model. Software centered systems that adopt this approach are able to accept goals, evaluate its capabilities and context and find the software modules that enable it to achieve its goals, fetch and install them. Also, the system can at runtime change its deployment in response to changes in its context, capabilities and available software modules.

%TODO: Why deployment matters
% executed multiple times during development and test.

The presented approach leverage context-goal models as the model that driven the adaptation. Goal modeling is an approach for system requirements that model the intentionality of actors.
%Goal-driven introspectiveness are a promising approach in dynamic systems. Goal-driven introspective system can reason about its goals at runtime and adapt to tackle changes in the environment.
Context runtime goal models insert the context as another dimension, modeling the variability of interest in the environment as context an how it affect the system goals and means of achieving its goals.
%The advantages of goal-driven adaptation is the high level of flexbility and easy the development by reuse the goal model.
Using Context-goal models to driven the deployment, we can avoid rework by reusing a model already developed in a requirements eliciting stage. Also, because goal-models are highly abstract models, we can achieve a higher level of flexibility. In addition, by using user goals as a drive of adaptation we expect to make deployment configuration accessible to users, even if they do not have technical skills in system administration.

%The idea is that with a support of a self-adaptive framework the system can achieve a high degree of autonomy in its deployment, allowing not specialized users configure the deployment by choosing the goals that they want to achieve in a given computing environment.
To execute the adaptation we propose the use of component-based adaptation in which the system is adapted by binding and unbinding software components at runtime. We find it promising as a component present a good level of abstraction (opposed to code or variable levels). It also builds upon mature component-based software engineering.

To allow open and decentralized evolution of the system we avoid the use of centralized design time models. Instead we propose break strategies to achieve goals as components that can be discovered at runtime. So third party developers can provide new components for achieve goals using different set of resources.

In order to easy the development of solutions that use the approach proposed in this work we are developing a reusable framework. The framework should have much the adaptation logic needed for the autonomous deployment.
