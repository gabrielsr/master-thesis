% In the last decade we have seen advances in the study of autonomic computing systems as an alternative to handle the crescent complexity of systems. The complexity in systems come with the need to execute in heterogeneous platforms, to run in multiple environments and handle multiple operation contexts.


With increasing popularity of mobile computation and wireless networks we have seen the rise of  interest in new domains of computation that uses the capacity of heterogeneous computer units in a given location.
Example of such domains are Ubiquitous Computing \cite{bell_yesterdays_2007}, Internet of Things (IoT)\cite{atzori_internet_2010}, Assisted Living\cite{kleinberger_ambient_2007} and Opportunistic Computing\cite{smaldone_improving_2011}. In such domains, the computing environment can greatly vary from place to place.
Solutions for these domains would benefit if they could plan the deployment of the system for a given computing environment at runtime.

% It's the case of \textit{mobile clouds} witch opportunistically form networks to harvest the power of mobile heterogeneous devices \cite{viswanathan_uncertainty-aware_2015}. Such systems could be mapped to multi-agent systems (MAS). In multi-agent systems each agent is a computerized unit capable of make independent decisions.
 Salehie at al. \cite{salehie_self-adaptive_2009} define self-adaptive software as one that adjust artifacts or attributes in response to changes in the \textit{self} and in the \textit{context} of a software system.
\textit{self} being \say{the whole body of software}. And \textit{context} being \say{everything in the operating environment that affects the system's properties and its behavior}.

Architecture-based (or component-based) self-adaptive approaches adapt the systems by acting on components of the system or by replacing them\cite{garlan_software_2009}. A possible solution for development of applications for environment with a high level of uncertainty would be to choose an architecture at runtime for the given environment, distributing software components between available computational units and setting up the right communication channels. But to make it possible we need also a model of the system so we can reason about possible system structures in face of the system requirements and context.
So it is important to trace system components back to requirements.

Goal Oriented Requirements Engineering (GORE) approaches have gained special attention as a technique to specify self-adaptative systems\cite{morandini_goal-oriented_2009}.
Goals capture, the various objectives the system under consideration should achieve\cite{van_lamsweerde_goal-oriented_2001}.

A multi-agent system (MAS) is a distributed computing system with autonomous interacting intelligent agents that coordinate their actions so as to achieve its goals\cite{woolridge_introduction_2001}.

Autonomous software agents provide a promising solution to the needs of decentralized networked systems, able to adapt their behaviour in a complex and dynamically changing environment \cite{morandini_goal-oriented_2009}.

Dalpiaz et al.\cite{dalpiaz_runtime_2013} proposed Runtime Goal Models to reason about runtime fulfillment of goals.

% DSPL (Dynamic Software Product Lines) provide models to check the configuration of the system.

% why get both together?
Goal models allow us to reason about the requirements of the system and its execution context, however lacks a structural view of the system to be. On the other hand, component-based software engineering (CBSE) explicitly addresses the system structure. To the best of our knowledge there is no integrated model to reason about the system structure in relation to its contexts and requirements.
In addition, we need methods to reason about the system levels of operation and change them at runtime, whenever needed. In this work, we propose to address those issues by devising a component-based model approach for self-adaptation relying on GORE (goal-oriented requirements engineering) and a component-based architecture model.

% Por exemplo existem contexto em que se faz necessário utilizar diferentes técnicas de tolerancia a falha a depender da criticidade das tarefas e do contexto de execução.
Such model would allow us to built more dependable systems. For example, we could choose to use fault tolerance techniques to more critical tasks of the system.
% desta forma é importante definir perviamente as estratégicas que ele pode atender em tempo de projeto e em tempo de execução garantir que elas sejam implementadas conforme definido em tempo de projeto.

 In this work we will explore the integration of approaches to allow reasoning about the relationship between the system goals, components and context of execution.
 The objective is be able to create valid deployment configurations, trace the system goals accomplishment at runtime and use fault tolerance techniques to improve the dependability of the system in face of error prone components.
